#!/usr/bin/env python
# coding: utf-8

# ### Анализ государственной поддержки кинопроизводства и зрительского спроса  
# 
# ## Описание проекта  
# 
# **Заказчик:** Министерство культуры РФ  
# 
# **Цель:**  
# Исследование рынка российского кинопроката с акцентом на эффективность государственной поддержки.  
# 
# **Ключевые вопросы:**  
# 1. Какова динамика производства фильмов с господдержкой?  
# 2. Какие жанры/студии получают наибольшее финансирование?  
# 3. Коррелирует ли размер поддержки с кассовыми сборами?  
# 4. Как зрители оценивают субсидируемые фильмы (по данным КиноПоиска)?  
# 
# ## Данные  
# 
# **Источники:**  
# 1. Портал открытых данных Минкультуры  
# 2. КиноПоиск (рейтинги)  
# 
# **Основные таблицы:**  
# 
# ### `mkrf_movies` (реестр прокатных удостоверений)  
# - `title`, `puNumber`, `show_start_date`  
# - `type`, `film_studio`, `production_country`  
# - `refundable_support`, `nonrefundable_support` (объемы господдержки)  
# - `ratings`, `genres` (данные с КиноПоиска)  
# 
# ### `mkrf_shows` (кассовые сборы)  
# - `puNumber`, `box_office`  
# 
# ## Методология  
# 
# 1. **Объединение данных** по уникальному идентификатору `puNumber`  
# 2. **Анализ трендов:**  
#    - Распределение поддержки по годам/жанрам  
#    - Сравнение сборов субсидируемых и независимых фильмов  
# 3. **ML-моделирование:**  
#    - Предсказание рейтинга на основе параметров поддержки  
#    - Кластеризация фильмов по эффективности вложений  

# ## Исследование данных о российском кинопрокате
# 
# 

# ### Шаг 1. Откройте файлы с данными и объедините их в один датафрейм. 
# 
# Объедините данные таким образом, чтобы все объекты из датасета `mkrf_movies` обязательно вошли в получившийся датафрейм. 
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_0" aria-expanded="false" aria-controls="collapseHint_0">Подсказка</button>
#         </div>
#         <div id="collapseHint_0" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# Обратите внимание на тип данных столбца, по которому будете соединять датафреймы. Тип данных этих столбцов должен быть одинаковым в обоих датафреймах.
#             </div>
#         </div>
#     </div>
# </div>

# In[1]:


import pandas as pd
import matplotlib.pyplot as plt


# In[2]:


try:
    data_movies = pd.read_csv('/datasets/mkrf_movies.csv')
except:
    data_movies = pd.read_csv('https://code.s3.yandex.net/datasets/mkrf_movies.csv')


# In[3]:


data_movies.info()


# In[4]:


data_movies['puNumber'] = pd.to_numeric(data_movies['puNumber'], errors = 'coerce')


# In[5]:


try:
    data_shows = pd.read_csv('/datasets/mkrf_shows.csv')
except:
    data_shows = pd.read_csv('https://code.s3.yandex.net/datasets/mkrf_shows.csv')


# In[6]:


data_shows.info()


# In[7]:


df = data_movies.merge(data_shows, on='puNumber', how='outer')


# In[8]:


df


# Потери данных после объединения файлов не произошло. Датафреймы объединились корректно.

# ### Шаг 2. Предобработка данных

# #### Шаг 2.1. Проверьте типы данных
# 
# - Проверьте типы данных в датафрейме и преобразуйте их там, где это необходимо.

# In[9]:


df.info()


# In[10]:


df


# Меняем тип данных в show_start_date на datetime64 для дальнейшей работы с датой. 
# Нам важен день выхода фильма, время не имеет значение, поэтому можешь оставить только дату.

# In[11]:


df['show_start_date'] = pd.to_datetime(df['show_start_date']).dt.tz_convert(None).dt.floor('D')


# Для дальнейшей работы с Series ratings нам надо поменять тип данных на float64. 
# В данном столбце присутствуют значение с процентами (например 99%). 
# Необходимо удалить знаки процента и все числа больше 10 разделить на 10.

# In[12]:


df['ratings'] = df['ratings'].str.replace('%', '').astype(float)
df.loc[df['ratings'] > 10, 'ratings'] /= 10


# #### Шаг 2.2. Изучите пропуски в датафрейме
# 
# - Объясните, почему заполнили пропуски определённым образом или почему не стали этого делать.

# In[13]:


df['title'].isna().sum()


# In[14]:


df['puNumber'].isna().sum()


# В столбце puNumber всего 1 пропуск, можем его удалить

# In[15]:


df= df.dropna(subset=['puNumber'])


# In[16]:


df['film_studio'].isna().sum()


# В столбце film_studio всего 18 пропусков, можем их удалить

# In[17]:


df= df.dropna(subset=['film_studio'])


# In[18]:


df['production_country'].isna().sum()


# В столбце production_country всего 1 пропуск, можем их удалить

# In[19]:


df= df.dropna(subset=['production_country'])


# In[20]:


df['director'].isna().sum()


# В столбце director всего 8 пропусков, можем их удалить

# In[21]:


df= df.dropna(subset=['director'])


# In[22]:


df['producer'].isna().sum()


# Пропуски в столбце producer не количественные значения. Заполнять 546 пропусков вручную, узнавая в интернете продюсера каждого фильма не представляется реальным. Оставим пропуски.

# In[23]:


df['refundable_support'].isna().sum()


# In[24]:


df['nonrefundable_support'].isna().sum()


# Пропуски в столбцах об объёме возвратных и невозвратных средств государственной поддержки можно заменить на ноль.

# In[25]:


df['refundable_support'] = df['refundable_support'].fillna(0)
df['nonrefundable_support'] = df['nonrefundable_support'].fillna(0)


# In[26]:


df['refundable_support'].isna().sum()


# In[27]:


df['nonrefundable_support'].isna().sum()


# In[28]:


df['budget'].isna().sum()


# Пропуски в столбцах про сумму бюджета (budget) составляют 95%. Заполнять их медианным, средним и каким либо еще значением не представляется возможным. Заполнить нулем тоже плохая идея, так как бюджет у фильма все же был. Оставим пропуски.

# In[29]:


df['financing_source'].isna().sum()


# Пропуски в столбцах об источнике государственного финансирования (financing_source) также составляют 95%. Это не количественные значения. Всего имеем три уникальных значения в этом столбце: 'Министерство культуры', 'Фонд кино',  'Министерство культуры, Фонд кино'. Оставим пропуски, так как нужно знать источник государственного финансирования для пропущенных фильмов и был ли этот источник вообще.

# In[30]:


# df['ratings'].isna().sum()


# ~~Пропуски в столбцe о рейтинге фильма заполним медианным значением.~~

# In[31]:


# df['ratings'] = df['ratings'].fillna(df['ratings'].median())


# In[32]:


# df['ratings'].isna().sum()


# In[33]:


df['genres'].isna().sum()


# Пропуски в столбце о жанре фильма (genres) составляют 956 значений, что много для простого удаления. Не количественные пропуски не получится заполнить значениями, так что оставим эти пропуски.

# In[34]:


df['box_office'].isna().sum()


# Пропуски в столбцах о сборе фильма (box_office) составляют 57%. Заполнять их медианным, средним и каким либо еще значением не представляется возможным. Заполнить нулем тоже плохая идея, так как сборы у фильма были. Оставим пропуски.

# In[35]:


df.reset_index(drop=True, inplace=True)


# Сбросим индексы

# #### Шаг 2.3. Изучите дубликаты в датафрейме
# - Проверьте, есть ли в данных дубликаты. Опишите причины, которые могли повлиять на появление дублей.

# In[36]:


df.duplicated().sum()


# Полностью дубликатов сток нет

# In[37]:


df['puNumber'].duplicated().sum()


# Смотрим дубликаты по номеру прокатного удостоверения, так как это единственный уникальный показатель, который не должен повторяться. 

# In[38]:


df.loc[df['puNumber'].duplicated(keep=False)] 


# Нашли 2 дубликата. Можем избавиться от них.

# In[39]:


df = df.drop_duplicates(subset='puNumber')


# Сбросим индексы

# In[40]:


df.reset_index(drop=True, inplace=True)


# Появления дубликатов могло быть вызвано несколькими причинами:
# 1. Несовершенством системы уникальных идентификаторов.
# 2. Человеческий фактор
# 3. Появление ошибки после объединения данных
# 

# #### Шаг 2.4. Изучите категориальные значения
# 
# - Посмотрите, какая общая проблема встречается почти во всех категориальных столбцах;
# - Исправьте проблемные значения в поле `type`.
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_1" aria-expanded="false" aria-controls="collapseHint_1">Подсказка</button>
#         </div>
#         <div id="collapseHint_1" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# В поле <code>type</code> есть несколько значений, у которых появился пробел в начале строки. Самый простой способ их «починить» -- использовать метод <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.str.strip.html#pandas.Series.str.strip">.str.strip</a>. Этот метод удаляет все пробелы, которые встречаются в начале и в конце строки. Применяют его таким образом:<br>
# <code>df['type'].str.strip()</code>
#             </div>
#         </div>
#     </div>
# </div>

# In[41]:


df


# In[42]:


df['title'].unique()


# In[43]:


df['title'].duplicated().sum()


# В столбце title с названиями фильмов встретилось 712 дубликатов. Но обрабатывать их не стоит, потому что до этого мы провели работу с прокатными удостоверениями, где было всего лишь 2 дубликата, а значит у всех этих 712 фильмов разные прокатные удостоверения. Причин дубликатов в названии может быть несколько: 
# 1. Выход фильма в прокат в разное время (повторные прокат например);
# 2. Это вообще разные фильмы, но называются одинаково.

# In[44]:


df['type'].unique()


# Убираем пробелы в столбце type которые встречаются до и/или после названия типа фильма.

# In[45]:


df['type'] = df['type'].str.strip()


# In[46]:


df['film_studio'].unique()


# In[47]:


len(df['film_studio'].unique())


# В столбце film_studio с названиями студий-производителей все наименования на кириллице (англоязычные названия студий, написанные латиницей, перевели транслитом на кириллицу). По этой причине я допускаю неявные дубликаты в этом столбце. Уникальных значений в этом столбце 5484 из 7456, что составляет 74%. Перебирать вручную все эти значения в поиске неявных дубликатов не представляется возможным.

# In[48]:


df['production_country'].unique()


# In[49]:


len(df['production_country'].unique())


# In[50]:


df['production_country'] = df['production_country'].str.replace(',', '-').str.replace(' -', '-').str.replace(' - ', '-').str.replace('- ', '-')
df['production_country'] = df['production_country'].str.strip()


# In[51]:


df['production_country'].unique()


# In[52]:


len(df['production_country'].unique())


# In[53]:


# def sort_and_join(values):
#     sorted_values = '-'.join(sorted(values))
#     return sorted_values

# df['production_country'] = df['production_country'].str.split('-')
# df['production_country'] = df['production_country'].apply(sort_and_join)


# В столбце production_country встречается ряд проблем:
# 
# 1. Пробелы перед первым и/или после последнего слова. Исправим это так же, как делали в столбце type.
# 2. Если стран производителей больше одной, то перечень этих стран может осуществляться через “-” или “,”. Сделаем перечень стран производителей через “-”.
# 3. В записи перечня стран через “-” могут содержаться пробелы до/после/до и после этого знака. Сделаем единую запись без пробелов.
# 4. ~~Если стран производителей больше одной, то запись этих стран может осуществляться в разном порядке, хотя и будет 2 уникальных значения: "Франция-Испания" и "Испания-Франция", например. Сделаем так, чтобы страны-производители шли в алфавитном порядке.~~
# 
# От последней идеи отказался, так как посчитал, что порядок стран может означать долю страны в производстве фильма. Страна, стоящая на первом месте, заняла большую долю в производстве этого фильма; на втором месте — страна с меньшей долей и т.д.
# 

# In[54]:


df['director'].unique()


# In[55]:


len(df['director'].unique())


# В столбце director с фамилиями режиссеров все наименования на кириллице (иностранные, написанные латиницей, перевели транслитом на кириллицу). По этой причине я допускаю неявные дубликаты в этом столбце. Уникальных значений в этом столбце 4795 из 7456, что составляет 64%. Перебирать вручную все эти значения в поиске неявных дубликатов не представляется возможным.

# In[56]:


df['producer'].unique()


# In[57]:


len(df['producer'].unique())


# В столбце producer с фамилиями продюсеров все наименования на кириллице (иностранные, написанные латиницей, перевели транслитом на кириллицу). По этой причине я допускаю неявные дубликаты в этом столбце. Уникальных значений в этом столбце 5329 из 7456, что составляет 71%. Перебирать вручную все эти значения в поиске неявных дубликатов не представляется возможным.

# In[58]:


df['age_restriction'].unique()


# In[59]:


df['genres'].unique()


# В столбцах age_restriction (возрастная категория) и genres (жанр фильма) проблем не нашел.

# #### Шаг 2.5. Проверьте количественные значения
# 
# - Проверьте, обнаружились ли в таких столбцах подозрительные данные. Как с такими данными лучше поступить?
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_budget" aria-expanded="false" aria-controls="collapseHint_budget">Подсказка</button>
#         </div>
#         <div id="collapseHint_budget" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# Обратите внимание на описание столбца <code>budget</code>. Как этот столбец соотносится с двумя другими: <code>refundable_support</code> и <code>nonrefundable_support</code>?
#             </div>
#         </div>
#     </div>
# </div>

# In[60]:


df


# In[61]:


df.groupby('refundable_support')['title'].count()


# In[62]:


df.groupby('nonrefundable_support')['title'].count()


# In[63]:


df.groupby('budget')['title'].count()


# В столбцах nonrefundable_support, budget и box_office встречался формат отображения чисел с научной нотацией (записи вида "e+07"). Избавимся от такой записи и оставим две точки после запятой.

# In[64]:


pd.options.display.float_format = '{:.2f}'.format


# In[65]:


df['refundable_support'].sort_values(ascending=False)


# Аномальных значений в столбце refundable_support не обнаружил.

# In[66]:


df['nonrefundable_support'].sort_values(ascending=False)


# Аномальных значений в столбце nonrefundable_support не обнаружил.

# In[67]:


df['budget'].sort_values(ascending=False)


# In[68]:


df['budget'].sort_values()


# Аномальных значений в столбце budget не обнаружил.

# In[69]:


df['box_office'].sort_values(ascending=False)


# In[70]:


df['box_office'].sort_values()


# Аномальных значений в столбце box_office не обнаружил.

# In[71]:


df.sort_values('budget', ascending=False)


# #### Шаг 2.6. Добавьте новые столбцы
# 
# 
# 
# 

# - Создайте столбец с информацией о годе проката. Выделите год из даты премьеры фильма.

# In[72]:


df['show_start_year'] = df['show_start_date'].dt.year


# - Создайте два столбца: с именем и фамилией главного режиссёра и основным жанром фильма. В столбцы войдут первые значения из списка режиссёров и жанров соответственно.
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_2" aria-expanded="false" aria-controls="collapseHint_2">Подсказка</button>
#         </div>
#         <div id="collapseHint_2" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# Чтобы создать такие столбцы, лучше всего использовать собственную функцию. Эту функцию можно применить к двум столбцам сразу. 
#             </div>
#         </div>
#     </div>
# </div>

# In[73]:


def extract_first_values(item):
    if pd.notna(item):
        return item.split(',')[0].strip()


# In[74]:


df['main_director'] = df['director'].apply(extract_first_values)
df['primary_genre'] = df['genres'].apply(extract_first_values)


# - Посчитайте, какую долю от общего бюджета фильма составляет государственная поддержка.

# In[75]:


df.loc[df['budget'] > 0, 'proportion_of_government_support'] = (df['refundable_support'] + df['nonrefundable_support']) / df['budget']


# In[76]:


df.sort_values('proportion_of_government_support', ascending=False)


# ### Шаг 3. Проведите исследовательский анализ данных
# 

# - Посмотрите, сколько фильмов выходило в прокат каждый год. Обратите внимание, что данные о прокате в кинотеатрах известны не для всех фильмов. Посчитайте, какую долю составляют фильмы с указанной информацией о прокате в кинотеатрах. Проанализируйте, как эта доля менялась по годам. Сделайте вывод о том, какой период полнее всего представлен в данных.

# In[77]:


pivot_box_office = df.pivot_table(index='show_start_year', values=['box_office', 'puNumber'], aggfunc='count')
pivot_box_office['rate'] = pivot_box_office['box_office'] / pivot_box_office['puNumber']
pivot_box_office.columns = ['box_office_info', 'total_film', 'rate']
pivot_box_office


# In[78]:


box_office_information = df.pivot_table(index='show_start_year', values='box_office', aggfunc='count')['box_office'].sum()
without_box_office_information = df.pivot_table(index='show_start_year', values='puNumber', aggfunc='count')['puNumber'].sum()
rate_of_films_with_bo_info = box_office_information / without_box_office_information
print('Общаяя доля фильмов с указанной информацией о прокате в кинотеатрах составляет:',
      '{:.0%}'.format(rate_of_films_with_bo_info))


# Общаяя доля фильмов с указанной информацией о прокате в кинотеатрах составляет: 42%

# In[79]:


pivot_box_office.plot(y = 'rate', kind='bar', figsize=(10, 8))
plt.title('График долей фильмов с указанной информацией о прокате в кинотеотрах по годам')
plt.xlabel('Год')
plt.ylabel('Доля фильмов')


# На графике долей фильмов с указанной информацией о прокате в кинотеатрах по годам видно, что с 2010 года до 2014 года эта доля плавно росла, но показатели её были слабыми. После 2015 года доля фильмов с указанной информацией значительно выросла. Причиной этого мог стать изданный закон для лучшего контроля киноиндустрии.

# - Изучите, как менялась динамика проката по годам. В каком году сумма сборов была минимальной? А максимальной?

# In[80]:


pivot_total_box_office = df.pivot_table(index='show_start_year', values='box_office', aggfunc='sum')
print(pivot_total_box_office)
pivot_total_box_office.plot(y='box_office', kind='bar', figsize=(10, 8))
plt.title('График суммарного сбора фильмов в кинотеатрах')
plt.xlabel('Год')
plt.ylabel('Сумма сборов')


# Динамика проката по годам напоминает предыдущий график, где до 2015 года информации о фильмах было мало по сравнению с последующими годами. Минимальная сумма сборов получилась в 2010 году. Максимальная — в 2018 году.

# - С помощью сводной таблицы посчитайте среднюю и медианную сумму сборов для каждого года.

# In[81]:


pivot_m_box_office = df.pivot_table(index='show_start_year', values='box_office', aggfunc=['mean', 'median'])
pivot_m_box_office.columns = ['mean_box_office', 'median_box_office']
pivot_m_box_office


# Столбец с данными по медианным суммам сборов показывает меньшие значения, чем столбец с средними значениями. Это объяснимо тем, что медианные значения менее подвержены влиянию выбросов в статистике. Однако как средний показатель, так и медианные показывают, что самым успешным годом по этим показателям был 2017.

# - Определите, влияет ли возрастное ограничение аудитории («6+», «12+», «16+», «18+» и т. д.) на сборы фильма в прокате в период с 2015 по 2019 год? Фильмы с каким возрастным ограничением собрали больше всего денег в прокате? Меняется ли картина в зависимости от года? Если да, предположите, с чем это может быть связано.

# In[82]:


# Строим диаграмму по каждому году с разделением по возрастным категориям
pivot_age_restriction_box_office = df.query("2015 <= show_start_year <= 2019").pivot_table(index='show_start_year', 
                                                                                           values='box_office', 
                                                                                           columns='age_restriction',
                                                                                           aggfunc='sum').plot(kind='bar', 
                                                                                                               figsize=(10, 8),
                                                                                                               grid = True)
plt.title('Доходы по возрастным ограничениям и годам')
plt.xlabel('Год и возростные ограничения')
plt.ylabel('Доход')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

# Составим сводную таблицу по сборам за каждый год для каждой возрастной категории. Сделаем срез данных начиная с 2015 года.
pivot_age_restriction_box_office_total = df.query("2015 <= show_start_year <= 2019").pivot_table(index='show_start_year', 
                                                                                           values='box_office', 
                                                                                           columns='age_restriction',
                                                                                           aggfunc='sum',
                                                                                           margins=True,
                                                                                           margins_name='total')
pivot_age_restriction_box_office_total = pivot_age_restriction_box_office_total.drop(columns=['total'])

# Построим диаграмму, аналогичную предыдущей, но с разделением по возрастным категориям для каждого года, включая столбец "total". 
# Я специально создаю отдельные диаграммы, так как данные "total" значительно выделяются в сравнении с остальными, 
# что может сделать диаграмму менее наглядной.
pivot_age_restriction_box_office_total.plot(kind='bar', figsize=(10, 8), grid = True)
plt.title('Доходы по возрастным ограничениям и годам с суммарными данными')
plt.xlabel('Год и возростные ограничения')
plt.ylabel('Доход')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

pivot_age_restriction_box_office_total


# Самые большие сборы у фильмов с рейтингом "16+". С 2016 года до 2018 года фильмы с этим рейтингом лидировали по сборам. В 2015 году больше всего собрали фильмы с рейтингом "12+". Однако, из-за того что у нас нет достаточного количества данных до 2015 года, точных выводов нельзя сделать, почему в 2015 году фильмы "16+" собрали меньше, чем фильмы "12+". Причиной этого может быть несколько вариантов:
# 1. 2015 год в целом выбивается из статистики.
# 2. 2015 год - первый год, когда начали передавать больший объем данных по фильмам, и из-за этого часть данных передалась некорректно.
# 3. В 2015 году сняли меньше фильмов "16+", чем в последующие годы.
# 
# В 2019 году фильмы "16+" также перестали лидировать, на что могли повлиять похожие факторы, как и в 2015 году. Однако 2019 год - самый свежий в статистике, поэтому проблема может заключаться не в том, что данные за начало года переданы некорректно, а, возможно, наоборот. На момент передачи данных год мог еще не завершиться или не полностью обработаться.

# ### Шаг 4. Исследуйте фильмы, которые получили государственную поддержку
# 
# На этом этапе нет конкретных инструкций и заданий — поищите интересные закономерности в данных. Посмотрите, сколько выделяют средств на поддержку кино. Проверьте, хорошо ли окупаются такие фильмы, какой у них рейтинг.

# In[83]:


df


# In[84]:


# Сгруппируем таблицу по рейтингу фильмов на которые выделялись либо возвратные средства либо невозвратные средства, 
# а также посмотрим сборы этих фильмов по рейтингу и сколько всего на него было выделено денег.

support_df = df.groupby('ratings')['refundable_support', 'nonrefundable_support', 'box_office'].sum()
support_df = support_df.query('refundable_support > 0 and nonrefundable_support > 0')
support_df['tota_support'] = support_df['refundable_support'] + support_df['nonrefundable_support']




support_df


# In[85]:


# Посмотрим среднее, медианное и общее количество возвратных средств
mean_refundable_support = support_df['refundable_support'].mean()
median_refundable_support = support_df['refundable_support'].median()
total_refundable_support = support_df['refundable_support'].sum()

print(f'Среднее количество возвратных средств выделенных на бюджет фильму: {mean_refundable_support:.2f} руб.')
print(f'Медианное количество возвратных средств выделенных на бюджет фильму: {median_refundable_support:.2f} руб.')
print(f'Всего выделено возвратных средств: {total_refundable_support:.2f} руб.')


# In[86]:


# Посмотрим среднее, медианное и общее количество невозвратных средств
mean_nonrefundable_support = support_df['nonrefundable_support'].mean()
median_nonrefundable_support = support_df['nonrefundable_support'].median()
total_nonrefundable_support = support_df['nonrefundable_support'].sum()

print(f'Среднее количество невозвратных средств выделенных на бюджет фильму: {mean_nonrefundable_support:.2f} руб.')
print(f'Медианное количество невозвратных средств выделенных на бюджет фильму: {median_nonrefundable_support:.2f} руб.')
print(f'Всего выделено невозвратных средств: {total_nonrefundable_support:.2f} руб.')


# In[87]:


# Посмотрим средней и медианный рейтинг поддерживаемых фильмов
mean_rating = support_df.reset_index()['ratings'].mean()
meadian_rating = support_df.reset_index()['ratings'].median()

print(f'Средний рейтинг фильмов, на которые выделялись деньги равен {mean_rating:.2f}')
print('Медианный рейтинг фильмов, на которые выделялись деньги равен', meadian_rating)


# Средние значения сумм, выделенных на бюджет фильмов, возвратных и невозвратных, оказались выше средних значений медиан. При этом не было обнаружено аномально высоких бюджетов. Можно сделать вывод, что более чем у половины фильмов бюджет ниже среднего.
# 
# Средний рейтинг фильмов, финансированных за счёт государства, составил 5.74, в то время как медианный рейтинг — 5.85. Более половины фильмов имеют рейтинг выше, чем среднее значение.
# 
# Более половины фильмов имеют бюджет ниже среднего, но в то же время более половины фильмов имеют рейтинг выше среднего. Возможно, стоит обратить внимание на определенные студии, режиссеров и продюсеров: уменьшить финансирование некоторых и увеличить другим.

# Создадим еще два столбца. Первый будет с разницей между сбором фильма и невозвратными средствами. Второй будет с разницей между сборами фильма и общей помощью.

# In[88]:


support_df['delta_nonrefundable_support'] = support_df['box_office'] - support_df['nonrefundable_support']
support_df['delta_total_support'] = support_df['box_office'] - support_df['tota_support']
support_df


# Отсортируем таблицу и посмотрим с каким рейтингом фильмы лучше всего окупаются.
# 

# In[89]:


delta_nonrefundable_support_table = support_df.sort_values('delta_nonrefundable_support', ascending=False)
delta_nonrefundable_support_table.head()


# In[90]:


delta_total_support_table = support_df.sort_values('delta_total_support', ascending=False).head()
delta_total_support_table.head()


# In[91]:


# Наиболее окупаемые фильмы получились одинаковые в обеих таблицах. 
# Возьмем средний рейтинг лучших фильмов по окупаемости.

mean_top_rating = delta_nonrefundable_support_table.reset_index()['ratings'].head().mean()
print(f'Лучше всего окупаются фильмы с рейтингом: {mean_top_rating:.2f}')


# Средний и медианный рейтинг фильмов, на которые выделяются деньги составляет 5.74 и 5.85 соответственно.
# Лучшая окупаемость у фильмов с рейтингом 6.84

# ### Шаг 5. Напишите общий вывод

# В начале данной работы были объединены два датафрейма в один.
# 
# Вторым шагом стала предобработка данных, в которую вошло:
# 1. Проверка типов данных и изменение тех типов данных, с которыми планировалась работа в дальнейшем.
# 2. Обработка пропусков в датафрейме. Часть пропусков была заполнена медианным значением, некоторые были заменены на нулевое значение. Также встречались пропуски, которые были удалены из данных. Однако часть пропусков осталась, так как она занимала большую часть данных, и не было возможности их заполнить или удалить.
# 3. Обработка дубликатов, в результате которой были удалены несколько дубликатов, найденных в номерах прокатных удостоверений.
# 4. Четвертым шагом в предобработке данных был поиск проблем в категориальных столбцах. Были удалены лишние пробелы, а также приведены к единому виду знаки разделения в тех столбцах, где содержалось более одного категориального значения.
# 5. В количественных данных я изменил отображение научной нотации (записи вида "e+07") на более привычную глазу.
# 6. После этого я добавил новые столбцы с информацией о годе проката, именами и фамилиями главных режиссеров и основными жанрами фильмов.
# 
# Третьим шагом исследования стал анализ данных.
# 
# Я обнаружил, что с 2010 года до 2014 года доля фильмов с указанной информацией о прокате в кинотеатрах плавно росла, но показатели были слабыми. После 2015 года доля фильмов с указанной информацией значительно выросла. Причиной этого мог стать изданный закон для лучшего контроля киноиндустрии.
# Данные по медианным суммам сборов показывают меньшие значения, чем данные со средними значениями. Это объяснимо тем, что медианные значения менее подвержены влиянию выбросов в статистике. Однако как средний показатель, так и медианные показывают, что самым успешным годом по этим показателям был 2017 год.
# Самые большие сборы у фильмов с рейтингом "16+". С 2016 года до 2018 года фильмы с этим рейтингом лидировали по сборам. В 2015 году больше всего собрали фильмы с рейтингом "12+". Однако из-за того, что у нас нет достаточного количества данных до 2015 года, точных выводов нельзя сделать, почему в 2015 году фильмы "16+" собрали меньше, чем фильмы "12+". Причиной этого может быть несколько вариантов:
# 1. 2015 год в целом выбивается из статистики.
# 2. 2015 год - первый год, когда начали передавать больший объем данных по фильмам, и из-за этого часть данных передалась некорректно.
# 3. В 2015 году сняли меньше фильмов "16+", чем в последующие годы.
# 4. В 2019 году фильмы "16+" также перестали лидировать, на что могли повлиять похожие факторы, как и в 2015 году. Однако 2019 год - самый свежий в статистике, поэтому проблема может заключаться не в том, что данные за начало года переданы некорректно, а, возможно, наоборот. На момент передачи данных год мог еще не завершиться или не полностью обработаться.
# 
# Более половины фильмов имеют бюджет ниже среднего, но в то же время более половины фильмов имеют рейтинг выше среднего. Возможно, стоит обратить внимание на определенные студии, режиссеров и продюсеров: уменьшить финансирование некоторых и увеличить другим.
# В завершение наблюдений можно сказать, что средний и медианный рейтинг фильмов, на которые выделяются деньги, составляет 5.74 и 5.85 соответственно. А лучшая окупаемость у фильмов с рейтингом 6.84.
# 
